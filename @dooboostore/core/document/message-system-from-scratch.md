
# 나만의 메시지 시스템 만들기: RxJS에 영감을 받은 여정

## 들어가며: 왜 또 하나의 메시지 시스템인가?

안녕하세요, 동료 개발자 여러분.

이 글은 제가 직접 만든 작고 귀여운(?) 메시지 시스템에 대한 이야기입니다. 아마 여러분 중 많은 분들이 '이미 RxJS 같은 훌륭한 라이브러리가 있는데, 왜 굳이 다시 만들었을까?'라는 의문을 가지실 겁니다. 정당한 질문입니다. 저 역시 처음에는 거대한 산처럼 보이는 RxJS를 그저 가져다 쓰기만 했습니다.

하지만 어느 날 문득 이런 생각이 들었습니다.

> "매일 사용하는 이 도구의 심장부에서는 과연 어떤 일이 일어나고 있을까?"

이 작은 호기심이 이 프로젝트의 시작이었습니다. 이 책은 단순히 API 사용법을 나열하는 것을 넘어, 다음과 같은 저의 경험과 깨달음을 공유하고자 합니다.

1.  **깊이 있는 학습:** 무언가를 가장 잘 이해하는 방법은 직접 만들어보는 것입니다. RxJS의 핵심 개념인 `Observable`, `Subject` 등을 직접 구현하며 반응형 프로그래밍의 정수를 파헤쳐 봅니다.
2.  **경량화와 최적화:** RxJS는 강력하지만, 때로는 프로젝트에 비해 너무 무겁게 느껴질 때가 있습니다. 우리에게 꼭 필요한 기능만을 담은 가벼운 시스템을 만들며 '필요'와 '기능' 사이의 균형을 고민해 봅니다.
3.  **통제와 유연성:** 직접 만든 시스템은 모든 코드를 제어할 수 있다는 강력한 장점이 있습니다. 버그를 추적하고, 원하는 방향으로 확장하는 과정의 즐거움을 나눕니다.

이 글을 읽는 여러분이 단순히 '구독자'로서 지식을 전달받는 것을 넘어, 저와 함께 이 시스템을 처음부터 만들어가는 '개발자'가 되기를 바랍니다. 자, 이제 함께 떠나볼까요?

---

## Chapter 1: 모든 것의 시작, `Observable`

우리의 여정은 `Observable` (관찰 가능 객체)에서 시작합니다. `Observable`을 한마디로 정의하면 **'미래에 도착할 값들을 담고 있는 상자'** 입니다. 이 상자는 누군가 "이제 값을 보내줘!"라고 구독(subscribe)하기 전까지는 아무 일도 하지 않습니다. 그래서 우리는 이것을 '게으르다(lazy)'고 표현합니다.

-   **신문 구독**을 생각해보세요. 신문사는 매일 새로운 신문을 만들지만(데이터 생성), 당신이 구독 신청을 하기 전까지는 신문을 배달하지 않습니다. `Observable`이 신문사이고, 당신이 바로 `Observer`(관찰자)입니다.

우리 시스템의 `Observable.ts`를 보면, 생성자에 `producerFunction` (생산자 함수)를 받는 것을 볼 수 있습니다.

```typescript
// Observable.ts 일부
export class Observable<T, E = any> {
  private _producerFunction: ((subscriber: Subscriber<T, E>) => ...);

  constructor(producerFunction?: ...) {
    this._producerFunction = producerFunction;
  }

  subscribe(...) {
    // ... 구독 시점에 producerFunction을 실행 ...
  }
}
```

이것이 핵심입니다. `subscribe`가 호출될 때 비로소 `producerFunction`이 실행되면서 데이터가 흐르기 시작합니다. 이를 **'Cold Observable'** 이라고 부릅니다. 모든 구독자에게는 각자 자신만의 데이터 흐름이 처음부터 새로 생성됩니다.

### `Observer`와 `Subscription`

-   **`Observer` (관찰자):** `Observable`이 보내는 값을 처리하는 객체입니다. 세 가지 신호에 반응합니다.
    -   `next(value)`: 새로운 값이 도착했을 때
    -   `error(err)`: 에러가 발생했을 때
    -   `complete()`: 모든 값이 성공적으로 전송되었을 때
-   **`Subscription` (구독):** `Observable`과 `Observer` 사이의 연결입니다. 가장 중요한 역할은 이 연결을 끊는 `unsubscribe()` 메서드를 제공하는 것입니다. 구독을 끊지 않으면, 원치 않는 메모리 누수가 발생할 수 있습니다. (이 중요성은 나중에 다시 강조하겠습니다.)

---

## Chapter 2: 뜨거운 심장, `Subject`

`Observable`이 각 구독자에게 개별적인 데이터 흐름을 제공하는 'Cold' 방식이라면, **`Subject`는 여러 구독자에게 동일한 데이터 흐름을 공유하는 'Hot' 방식**입니다.

-   **라디오 방송**을 생각해보세요. DJ가 음악을 틀면(데이터 생성), 모든 청취자는 그 순간에 방송되는 동일한 음악을 듣습니다. 늦게 라디오를 켠 청취자는 이전 음악을 들을 수 없습니다. `Subject`가 바로 이 라디오 방송국입니다.

`Subject`는 `Observable`이면서 동시에 `Observer`입니다.

1.  `Observable`로서: 여러 `Observer`가 `subscribe()` 할 수 있습니다.
2.  `Observer`로서: 외부에서 `next()`, `error()`, `complete()` 메서드를 호출하여 `Subject`에 값을 주입할 수 있습니다.

이 특성 덕분에 `Subject`는 애플리케이션의 여러 부분에서 발생하는 이벤트를 한 곳으로 모아 전파하는 **이벤트 버스(Event Bus)** 역할을 하기에 완벽합니다.

### 특별한 `Subject` 삼 형제

우리 시스템에는 세 가지 특별한 `Subject`가 있습니다.

1.  **`BehaviorSubject`**: "최신 소식은 꼭 알려줄게!"
    -   생성 시 반드시 초기값을 가집니다.
    -   새로운 구독자가 생기면, 가장 마지막에 발행했던 값을 즉시 전달해 줍니다.
    -   '현재 상태'를 관리하고 공유하는 데 매우 유용합니다. (예: 현재 로그인된 사용자 정보)

2.  **`ReplaySubject`**: "놓친 소식도 다시 챙겨줄게!"
    -   지정된 개수만큼 최신 값들을 버퍼에 저장합니다.
    -   새로운 구독자가 생기면, 버퍼에 저장된 값들을 순서대로 모두 전달해 줍니다.
    -   채팅 기록이나 사용자 행동 로그처럼, 최근 N개의 데이터가 중요할 때 유용합니다.

3.  **`AsyncSubject`**: "결과만 알려줄게!"
    -   `complete()`가 호출되기 직전의 **마지막 값 하나만** 발행합니다.
    -   `complete()`가 호출되지 않으면 아무 값도 발행하지 않습니다.
    -   비동기 작업이 모두 완료되었을 때 최종 결과만 필요한 경우에 적합합니다.

---

## Chapter 3: 데이터 흐름을 조각하다, `연산자(Operators)`

RxJS의 가장 강력한 기능 중 하나는 바로 '연산자'입니다. 연산자는 `Observable`이 발행하는 데이터의 흐름을 우리가 원하는 대로 가공하고 조합하는 순수 함수들입니다. `Observable.pipe()` 메서드를 통해 이 연산자들을 체인처럼 연결할 수 있습니다.

-   **물의 정수 과정**을 상상해보세요. 흙탕물이 파이프(`pipe`)를 통과하며, 첫 번째 필터(`filter`)에서 큰 불순물이 걸러지고, 두 번째 필터(`map`)에서 미네랄이 추가되는 과정과 같습니다.

우리 시스템에서도 몇 가지 핵심적인 연산자를 구현했습니다.

-   `map<T, R>((value: T) => R)`: 들어온 값(T)을 새로운 값(R)으로 변환합니다. (예: `user` 객체에서 `userName`만 추출)
-   `filter<T>((value: T) => boolean)`: 특정 조건(predicate)을 만족하는 값만 통과시킵니다.
-   `debounceTime(duration)`: 지정된 시간 동안 새로운 값이 들어오지 않아야 마지막 값을 발행합니다. (예: 검색창 자동완성 기능)
-   `distinctUntilChanged()`: 바로 이전에 발행된 값과 동일한 값은 무시합니다.

이러한 연산자들을 통해 우리는 복잡한 비동기 로직을 선언적이고 읽기 쉽게 표현할 수 있습니다.

---

## Chapter 4: 만들면서 배운 것들

이 시스템을 만들면서 기술적인 부분 외에도 많은 것을 배울 수 있었습니다.

1.  **`unsubscribe`의 중요성을 뼈저리게 느끼다.**
    초기 버전에서는 `unsubscribe` 로직을 소홀히 다루었습니다. 그 결과, 컴포넌트가 사라져도 구독이 살아남아 보이지 않는 곳에서 계속 실행되는 메모리 누수를 경험했습니다. **"구독은 반드시 해제되어야 한다"** 는 반응형 프로그래밍의 제1원칙을 몸으로 깨달았습니다.

2.  **Cold와 Hot의 명확한 차이를 이해하다.**
    이론으로만 알던 'Cold'와 'Hot'의 차이를 직접 구현하며 명확히 이해하게 되었습니다. HTTP 요청처럼 호출할 때마다 새로운 실행이 필요한 곳에는 `Observable`을, UI 이벤트나 상태 공유처럼 여러 곳에서 하나의 흐름을 공유해야 할 때는 `Subject`를 사용해야 한다는 원칙을 세울 수 있었습니다.

3.  **순수 함수의 위대함.**
    연산자를 만들면서 `map`, `filter` 같은 순수 함수들이 어떻게 코드의 복잡성을 낮추고 예측 가능성을 높이는지 실감했습니다. 입력이 같으면 항상 출력이 같은 순수 함수의 특성은 비동기 코드의 디버깅을 훨씬 쉽게 만들어 주었습니다.

## 맺음말

지금까지 저와 함께 작은 메시지 시스템을 만드는 여정을 함께해 주셔서 감사합니다. 이 글이 여러분에게 반응형 프로그래밍의 내부 동작에 대한 작은 호기심을 심어주고, 더 나아가 자신만의 도구를 만들어보는 즐거움으로 이어졌으면 하는 바람입니다.

코드는 완벽하지 않을 수 있습니다. 하지만 이 코드를 통해 저는 성장했고, 이 경험을 공유할 수 있어 기쁩니다. 이제 여러분 차례입니다. 직접 코드를 살펴보시고, 수정하고, 새로운 연산자를 추가해보세요.

세상에서 가장 좋은 공부는 '직접 만들어보는 것'이니까요.
