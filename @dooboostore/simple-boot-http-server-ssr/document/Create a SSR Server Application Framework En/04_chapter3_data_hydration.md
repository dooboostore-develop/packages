# Chapter 3: Data Hydration - SaveAroundAfter and LoadAroundBefore

Data hydration is one of the core concepts of Server-Side Rendering (SSR). It is a technique for transferring the data used with the server-rendered HTML to the client, so that the client-side JavaScript can activate the UI without re-rendering the page. `Simple-Boot-HTTP-SSR` automates this process with the `SaveAroundAfter` and `LoadAroundBefore` decorators. This chapter explores the detailed implementation and usage of these two decorators.

## 3.1. Server-Side Data Saving (`SaveAroundAfter`)

The `SaveAroundAfter` decorator is responsible for saving the return value of a method executed on the server to the `window.server_side_data` object. This data is ultimately included in the HTML sent to the client.

### Implementation Principle

`SaveAroundAfter` works similarly to the `@Around` decorator from `@dooboostore/simple-boot`. It directly modifies the method descriptor (`descriptor.value`) to wrap the original method. The wrapped method intercepts the return value after the original method is executed and saves it to `window.server_side_data`.

-   **Key Generation:** The key used to store the data is generated by combining the `scheme` of the `@Sim` class to which the method belongs and the method name (e.g., `UserService_getUserById`).
-   **`window.server_side_data`:** This object exists on the `window` object in the JSDOM environment and serves as a container for temporarily storing all server-rendered data.
-   **Asynchronous Handling:** If the method's return value is a `Promise`, it is handled so that the data is saved after the `Promise` is resolved, ensuring that asynchronous data can also be correctly hydrated.

```typescript
// decorators/SaveAroundAfter.ts (Conceptual)
import { getSim } from '@dooboostore/simple-boot/decorators/SimDecorator';

export const SaveAroundAfter = (obj: any, propertyKey: string, args: any[], beforeReturn: any) => {
    const simOption = obj._SimpleBoot_simOption; // Access SimFrontOption of SimpleBootFront
    const config = getSim(obj); // Get the configuration of the @Sim decorator

    if (simOption && config?.scheme && simOption.window) {
        if (!simOption.window.server_side_data) {
            simOption.window.server_side_data = {}; // Initialize the server_side_data object
        }
        const key = config.scheme + '_' + propertyKey; // Generate the key for storage

        if (beforeReturn instanceof Promise) {
            // If it's a Promise, save the data after it's resolved
            beforeReturn.then((resolvedData) => {
                simOption.window.server_side_data[key] = JSON.stringify(resolvedData); // Save as a JSON string
                return resolvedData;
            });
        } else {
            // If it's not a Promise, save the data immediately
            simOption.window.server_side_data[key] = JSON.stringify(beforeReturn); // Save as a JSON string
        }
    }
    return beforeReturn; // Return the original return value
};
```

## 3.2. Client-Side Data Loading (`LoadAroundBefore`)

The `LoadAroundBefore` decorator helps a method executed on the client to reuse data that has already been fetched on the server. Before the method with this decorator is called, it looks for and returns the corresponding data from `window.server_side_data`.

### Implementation Principle

Like `SaveAroundAfter`, `LoadAroundBefore` modifies the method descriptor to wrap the original method. The wrapped method checks `window.server_side_data` before the original method is executed.

-   **Data Retrieval:** It retrieves data from `window.server_side_data` using the same key that `SaveAroundAfter` used to store it.
-   **Skipping Execution:** If the data exists, it skips the execution of the original method and returns the data stored in `window.server_side_data`. It uses `AroundForceReturn` to forcefully stop the method execution and return the value.
-   **Asynchronous Handling:** If the stored data was the result of a `Promise`, it is wrapped with `Promise.resolve()` to maintain the asynchronous context.

```typescript
// decorators/LoadAroundBefore.ts (Conceptual)
import { AroundForceReturn } from '@dooboostore/simple-boot/decorators/aop/AOPDecorator';
import { getSim } from '@dooboostore/simple-boot/decorators/SimDecorator';

export const LoadAroundBefore = (obj: any, propertyKey: string, args: any[]) => {
    const simOption = obj._SimpleBoot_simOption; // Access SimFrontOption of SimpleBootFront
    const config = getSim(obj); // Get the configuration of the @Sim decorator

    if (simOption && config?.scheme && simOption.window) {
        const key = config.scheme + '_' + propertyKey; // Generate the same key as the one used for storage
        const isHas = (key in (simOption.window.server_side_data ?? {})); // Check if the data exists

        if (isHas) {
            const data = simOption.window.server_side_data?.[key];
            delete simOption.window.server_side_data?.[key]; // Delete the used data

            let rdata;
            // If the stored data was the result of a Promise, wrap it with Promise.resolve
            try {
                rdata = JSON.parse(data); // Deserialize the JSON string into an object
            } catch (e) {
                rdata = data; // If parsing fails, return the original string
            }

            // Skip the execution of the original method and return the data
            throw new AroundForceReturn(rdata instanceof Promise ? rdata : Promise.resolve(rdata));
        }
    }
    return args; // If there is no data, return the original method arguments (execute the original method)
};
```

## 3.3. Data Serialization and Deserialization

When transferring data from the server to the client, it must be converted into a format that can be transmitted over the network. This is usually done through a process called **Serialization**. In `Simple-Boot-HTTP-SSR`, `JSON.stringify()` is used to serialize data into a JSON string, and `JSON.parse()` is used on the client to deserialize it.

-   **Server-Side (`SaveAroundAfter`):** The return value of the method is converted into a JSON string using `JSON.stringify()` and stored in `window.server_side_data`.
-   **Client-Side (`LoadAroundBefore`):** The JSON string retrieved from `window.server_side_data` is restored to its original JavaScript object form using `JSON.parse()`.

### Example: Using Data Hydration Decorators

```typescript
// server.ts (Server-side code)
import 'reflect-metadata';
import { SimpleBootHttpSSRServer, HttpSSRServerOption } from '@dooboostore/simple-boot-http-server-ssr';
import { Sim, Router, Route } from '@dooboostore/simple-boot';
import { GET, Mimes } from '@dooboostore/simple-boot-http-server';
import { SaveAroundAfter } from '@dooboostore/simple-boot-http-server-ssr/decorators/SaveAroundAfter';

// 1. Server-side data service
@Sim({ scheme: 'data-service' }) // Set scheme (used for generating hydration key)
class ServerDataService {
    @SaveAroundAfter // Save the return value of this method to window.server_side_data
    async fetchUserData(userId: number) {
        console.log(`[Server] Fetching user data for ID: ${userId} from DB...`);
        // Actual database query or external API call
        await new Promise(resolve => setTimeout(resolve, 100)); // Mock asynchronous operation
        return { id: userId, name: `Server User ${userId}`, email: `user${userId}@example.com` };
    }

    @SaveAroundAfter
    async fetchProductList() {
        console.log(`[Server] Fetching product list...`);
        await new Promise(resolve => setTimeout(resolve, 50));
        return [{ id: 1, name: 'Laptop' }, { id: 2, name: 'Mouse' }];
    }
}

// 2. Server-side router
@Sim
@Router({ path: '' })
class ServerAppRouter {
    constructor(private serverDataService: ServerDataService) {}

    @Route({ path: '/user/{id}' })
    @GET({ res: { contentType: Mimes.TextHtml } }) // HTML response
    async userPage(rr: RequestResponse, routerModule: RouterModule) {
        const userId = parseInt(routerModule.pathData?.id || '0');
        // Pre-fetch data on the server so that the front-end component can use it
        await this.serverDataService.fetchUserData(userId); // Data is saved by SaveAroundAfter
        await this.serverDataService.fetchProductList(); // Data is saved by SaveAroundAfter
        // In reality, the logic to render the front-end app is called here (handled by SSRFilter)
        return 'HTML will be rendered by SSRFilter';
    }
}

const httpServerOption = new HttpSSRServerOption({
    listen: { port: 3000 },
    rootRouter: ServerAppRouter,
    // ... SSRFilter configuration (see previous chapter) ...
});

const app = new SimpleBootHttpSSRServer(httpServerOption);
app.run();

console.log('SSR Server with Data Hydration example started.');
```

**`templates/user-profile.component.html`**
```html
<!-- templates/user-profile.component.html -->
<h1>User Profile</h1>
<p>ID: ${this.user?.id}$</p>
<p>Name: ${this.user?.name}$</p>
<p>Email: ${this.user?.email}$</p>
<h2>Products</h2>
<ul>
  <li dr-for-of="this.products">${#it.name}$</li>
</ul>
```

```typescript
// client.ts (Client-side code - runs in the browser)
import 'reflect-metadata';
import { SimpleBootFront } from '@dooboostore/simple-boot-front/SimpleBootFront';
import { SimFrontOption, UrlType } from '@dooboostore/simple-boot-front/option/SimFrontOption';
import { Sim, Router, Route } from '@dooboostore/simple-boot';
import { Component } from '@dooboostore/simple-boot-front/decorators/Component';
import { LoadAroundBefore } from '@dooboostore/simple-boot-http-server-ssr/decorators/LoadAroundBefore';
import template from './templates/user-profile.component.html'

// 1. Client-side data service (uses the same scheme and method names as the server-side)
@Sim({ scheme: 'data-service' })
class ClientDataService {
    @LoadAroundBefore // Before calling this method, try to load data from window.server_side_data
    async fetchUserData(userId: number) {
        console.log(`[Client] Fetching user data for ID: ${userId} from API...`);
        // If there is no data from the server, make an actual API call
        const response = await fetch(`/api/users/${userId}`);
        return response.json();
    }

    @LoadAroundBefore
    async fetchProductList() {
        console.log(`[Client] Fetching product list from API...`);
        const response = await fetch(`/api/products`);
        return response.json();
    }
}

// 2. Client-side component
@Sim
@Component({
  template
})
class UserProfileComponent {
  user: any;
  products: any[] = [];

  constructor(private clientDataService: ClientDataService) {}

  async onInit() {
    // Load data when the component is initialized on the client
    // If the data has already been fetched on the server, LoadAroundBefore will return it immediately without an API call
    const userId = parseInt(window.location.pathname.split('/').pop() || '0');
    this.user = await this.clientDataService.fetchUserData(userId);
    this.products = await this.clientDataService.fetchProductList();
    console.log('[Client] User data loaded:', this.user);
    console.log('[Client] Product data loaded:', this.products);
  }
}

// 3. Client-side router
@Sim
@Router({ path: '' })
@Component({
  template: `<router dr-this="this.child"></router>`
})
class ClientAppRouter {
  child?: any;
  async canActivate(url: any, module: any) {
    this.child = module;
  }

  @Route({ path: '/user/{id}', target: UserProfileComponent })
  userRoute() {}
}

const config = new SimFrontOption(window)
  .setRootRouter(ClientAppRouter)
  .setUrlType(UrlType.path) // Use the same URL type as the server
  .setSelector('#app');

const app = new SimpleBootFront(config);
app.run();

console.log('Client-side application started.');

/*
How to run:
1. Run server.ts (Node.js)
2. Bundle client.ts with webpack or similar and include it in the HTML
3. Open http://localhost:3000/user/123 in a browser

Expected output (server console):
[Server] Fetching user data for ID: 123 from DB...
[Server] Fetching product list...

Expected output (client console):
[Client] User data loaded: { id: 123, name: 'Server User 123', ... }
[Client] Product data loaded: [...] (Data from the server is used without an API call)
*/
```

This chapter explored the implementation principle and usage of the `SaveAroundAfter` and `LoadAroundBefore` decorators, the core of data hydration. This allows for efficient reuse of server-rendered data on the client to optimize initial loading performance.

The next chapter will explore how `Simple-Boot-HTTP-SSR` integrates with `Simple-Boot Core` and `Simple-Boot-Front` to achieve an optimized integration for the SSR environment.
