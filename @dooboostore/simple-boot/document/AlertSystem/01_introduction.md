# 서문: 왜 새로운 Alert System을 구축하는가?

사용자에게 정보를 전달하는 '알림(Alert)'은 모든 인터랙티브 애플리케이션의 기본적인 기능입니다. 가장 간단하게는 브라우저의 `window.alert()`를 사용할 수 있지만, 이는 사용자 경험을 해치는 치명적인 단점(모달 방식, UI 커스텀 불가)을 가지고 있습니다. 이 때문에 대부분의 프로젝트에서는 자체적인 알림 컴포넌트를 만들어 사용합니다.

하지만 여기서 새로운 문제가 발생합니다. 알림을 필요로 하는 모든 컴포넌트나 서비스가 각자 UI 컴포넌트를 직접 생성하고 제어하기 시작하면, 코드는 강하게 결합되고 재사용성이 떨어집니다. API 통신 결과를 알리는 로직, 폼 유효성 검사 결과를 알리는 로직 등이 곳곳에 흩어져 일관성을 유지하기 어려워집니다.

이 책은 이러한 문제들을 해결하기 위해, **어떻게 하면 애플리케이션 전반에 걸쳐 일관되고, 유연하며, 확장 가능한 알림 시스템(Alert System)을 직접 설계하고 구현할 수 있는지** 그 본질을 탐구합니다. 우리는 `@dooboostore/simple-boot`의 `Alert` 관련 모듈들을 통해, 잘 설계된 알림 시스템의 내부를 함께 들여다볼 것입니다.

이 책의 목표는 독자 여러분이 단순히 알림 UI를 만드는 것을 넘어, 그 이면의 아키텍처를 이해하고, 어떤 상황에서든 재사용 가능한 알림 서비스를 구축할 수 있는 깊이 있는 지식과 통찰력을 얻도록 돕는 것입니다.

## `AlertSystem`의 핵심 특징

-   **느슨한 결합(Loose Coupling):** 알림을 요청하는 코드(Requesting Code)와 알림을 실제로 화면에 그리는 UI 컴포넌트가 완전히 분리됩니다.
-   **팩토리 패턴(Factory Pattern):** `AlertFactory`를 통해 알림 객체의 생성을 중앙에서 관리하며, 프론트엔드와 백엔드(SSR) 같은 다른 환경에 따라 각기 다른 알림 구현을 제공할 수 있습니다.
-   **중앙 집중식 서비스:** `AlertService`를 통해 애플리케이션의 모든 알림 요청을 단일 창구에서 처리하고 제어합니다.
-   **반응형(Reactive) 관리:** RxJS를 사용하여 알림의 생성과 소멸 이벤트를 스트림으로 전파하고, 이를 구독하여 UI를 동적으로 관리합니다.
-   **확장성:** 새로운 종류의 알림을 추가하고 싶을 때, 기존 코드를 수정할 필요 없이 새로운 `Alert` 클래스와 팩토리 로직만 추가하면 시스템이 자동으로 확장됩니다.

## 이 책에서 다룰 주요 내용

-   **핵심 추상화:** 모든 알림의 기반이 되는 `Alert` 클래스와, 알림 생성 책임을 위임받는 `AlertFactory` 인터페이스의 역할을 학습합니다.
-   **팩토리 패턴 활용:** 프론트엔드와 백엔드 환경에 따라 어떻게 다른 알림 객체가 생성되는지 그 원리를 알아봅니다.
-   **UI 컴포넌트 연동:** 추상화된 `Alert` 객체가 실제로 화면에 보이는 UI 컴포넌트와 어떻게 연결되는지 살펴봅니다.
-   **반응형 상태 관리:** `AlertService`가 RxJS를 이용해 알림의 생명주기를 관리하고, UI가 이에 어떻게 반응하는지 탐구합니다.
-   **전체 시스템 조립:** `ApiService`와 같은 다른 서비스에서 `AlertService`를 활용하는 최종 사용 예시를 통해 전체 그림을 완성합니다.

이제, 잘 설계된 `AlertSystem`을 구축하는 여정을 함께 시작하겠습니다.
