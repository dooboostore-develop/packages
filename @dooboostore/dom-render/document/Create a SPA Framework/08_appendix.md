# 부록: 더 나아가기

이 책을 통해 우리는 `dom-render`라는 프레임워크의 핵심을 처음부터 끝까지 만들어보는 여정을 함께했습니다. 이 부록에서는 `dom-render`의 아키텍처를 객관적으로 평가하고, 앞으로 프레임워크를 어떻게 더 발전시킬 수 있을지, 그리고 프레임워크 개발자로서 어떻게 성장할 수 있을지에 대한 아이디어를 공유합니다.

## A. `dom-render` 아키텍처의 장단점

모든 기술적 선택에는 장점과 단점이 따릅니다. 우리가 만든 프레임워크도 예외는 아닙니다.

### 장점

-   **학습 곡선:** `Proxy`와 순수 JavaScript 객체를 기반으로 하므로, 특별한 API나 개념(예: `useState`, `useEffect`)을 많이 배울 필요 없이 직관적으로 사용할 수 있습니다.
-   **성능:** 가상 DOM이 없어 메모리 사용량이 적고, 정밀한 의존성 추적 덕분에 불필요한 렌더링이 발생하지 않습니다. 간단한 애플리케이션에서는 매우 뛰어난 성능을 보입니다.
-   **유연성:** 핵심 로직이 특정 뷰 라이브러리에 종속되지 않습니다. `Operator` 패턴과 `config` 객체를 통해 프레임워크의 동작을 쉽게 확장하거나 수정할 수 있습니다.
-   **HTML 친화적:** 모든 로직이 HTML 템플릿 안에 선언적으로 작성되므로, 디자이너나 마크업 개발자와의 협업이 용이합니다.

### 단점

-   **디버깅의 어려움:** `Proxy`는 객체의 동작을 투명하게 가로채기 때문에, 데이터의 변경이 어디서 시작되었는지 추적하기가 어려울 수 있습니다. 브라우저 개발자 도구에서 `Proxy` 객체를 검사하는 것도 일반 객체보다 복잡합니다.
-   **정적 분석의 한계:** 템플릿 내의 표현식이 문자열로 처리되므로, 컴파일 타임에 오류를 잡거나 타입을 체크하기가 어렵습니다. (TypeScript의 이점을 완전히 살리지 못할 수 있습니다.)
-   **최적화의 부재:** 현재 `dr-for-of` 구현은 배열이 변경될 때마다 전체 목록을 다시 렌더링합니다. 수백, 수천 개의 아이템을 다룰 경우 성능 문제가 발생할 수 있습니다.
-   **생태계:** 성숙한 프레임워크들이 제공하는 방대한 라이브러리, 개발자 도구, 커뮤니티 지원이 부족합니다.

## B. 성능 개선을 위한 아이디어

`dom-render`를 한 단계 더 발전시키기 위한 몇 가지 아이디어입니다.

1.  **DOM 업데이트 배치(Batching):** 짧은 시간 안에 여러 데이터가 연속으로 변경될 때(예: 루프 안에서 속성 값 변경), DOM 업데이트를 한 번에 모아서 실행하는 스케줄러를 도입할 수 있습니다. `requestAnimationFrame`을 사용하면 브라우저의 다음 페인트 시점에 맞춰 렌더링을 동기화하여 성능을 향상시킬 수 있습니다.

2.  **Keyed-Diffing 알고리즘 구현:** `dr-for-of` 지시어에 `key` 속성을 도입하여, 배열의 각 아이템에 고유한 식별자를 부여합니다. 배열이 변경되면, 이전 DOM 노드와 새로운 데이터 배열을 `key`를 기준으로 비교하여, 이동, 추가, 삭제가 필요한 노드를 최소한으로 계산하여 DOM을 조작합니다. 이는 리스트 렌더링 성능을 극적으로 향상시키는 가장 중요한 최적화입니다.

3.  **컴파일러 도입:** 빌드 시점에 템플릿을 정적으로 분석하는 간단한 컴파일러를 도입할 수 있습니다. 예를 들어, `${this.name}$` 같은 표현식을 `_renderTextNode(this.name)` 같은 함수 호출로 변환하면, 런타임에 정규표현식으로 파싱하는 비용을 줄일 수 있고, 더 많은 최적화 기회를 얻을 수 있습니다.

## C. 프레임워크 개발자로서의 성장 로드맵

프레임워크를 직접 만들어 본 경험은 여러분을 더 나은 개발자로 만들어 줄 것입니다. 여기서 멈추지 말고 다음 단계로 나아가 보세요.

-   **다른 프레임워크 소스 코드 읽기:** 이제 여러분은 React, Vue, Svelte의 소스 코드를 읽을 수 있는 기초 체력을 갖췄습니다. 그들이 같은 문제를 어떻게 다른 방식으로 해결했는지 비교 분석해보세요. 특히 렌더링 스케줄러, 동시성(Concurrency) 처리, 상태 관리 라이브러리(Redux, Pinia)의 구현은 많은 영감을 줄 것입니다.

-   **브라우저 렌더링 과정 깊이 이해하기:** 브라우저가 HTML을 파싱하고, CSS를 계산하며, 픽셀을 화면에 그리기까지의 과정(Critical Rendering Path)을 학습하세요. 이는 프레임워크 성능 최적화의 근본적인 배경지식이 됩니다.

-   **자신만의 작은 라이브러리 만들기:** 꼭 프레임워크가 아니어도 좋습니다. 상태 관리, 라우팅, 국제화(i18n) 등 특정 문제를 해결하는 작은 라이브러리를 만들어보세요. 이는 소프트웨어 설계 능력을 연마하는 좋은 훈련이 됩니다.

프레임워크 개발은 단순히 코드를 작성하는 행위를 넘어, 문제 해결에 대한 철학과 아이디어를 아키텍처로 표현하는 예술과 같습니다. 이 책이 여러분의 즐거운 여정에 작은 등대가 되었기를 바랍니다.
