import { RawSet, RenderResult } from './rawsets/RawSet';
import { EventManager, NormalAttrDataType } from './events/EventManager';
import { DomRenderConfig } from './configs/DomRenderConfig';
import { ScriptUtils } from '@dooboostore/core-web/script/ScriptUtils';
import { DomRenderFinalProxy, Shield } from './types/Types';
import { RawSetType } from './rawsets/RawSetType';
import { DrThisProperty } from './operators/DrThisProperty';
import { RawSetOperatorType } from './rawsets/RawSetOperatorType';
import { ComponentSet } from './components/ComponentSet';
import { DomRenderNoProxyKey, isDomRenderNoProxy } from './decorators/DomRenderNoProxy';
import { isOnCreateRender } from './lifecycle/OnCreateRender';
import { isOnInitRender } from './lifecycle/OnInitRender';
import { isOnCreateRenderData } from './lifecycle/OnCreateRenderData';
import { isOnChangeAttrRender } from './lifecycle/OnChangeAttrRender';
import { DocumentUtils } from '@dooboostore/core-web/document/DocumentUtils';
import { isDefined } from '@dooboostore/core/types';
import { isOnBeforeReturnSet } from './lifecycle/OnBeforeReturnSet';
import { isOnChildRenderedByProperty } from './lifecycle/OnChildRenderedByProperty';
import { ObjectUtils } from '@dooboostore/core/object/ObjectUtils';
import { ValidUtils } from '@dooboostore/core/valid/ValidUtils';
import { isOnProxyDomRender } from './lifecycle/OnProxyDomRender';
import { isOnRawSetRendered } from './lifecycle/OnRawSetRendered';

const excludeGetSetPropertys = [
  'onBeforeReturnGet',
  'onBeforeReturnSet',
  '__domrender_components',
  '__render',
  '_DomRender_isFinal',
  '_domRender_ref',
  '_rawSets',
  '_domRender_proxy',
  '_targets',
  '_DomRender_origin',
  '_DomRender_ref',
  '_DomRender_proxy'
];
export const isWrapProxyDomRenderProxy = <T>(obj: T): boolean => {
  return obj && typeof obj === 'object' && '_DomRender_isProxy' in obj;
};
export const getDomRenderOriginObject = <T>(obj: T): T => {
  if (isWrapProxyDomRenderProxy(obj)) {
    return (obj as any)._domRender_origin;
  }
  return obj;
};
export const getDomRenderConfig = (obj: any): DomRenderConfig | undefined => {
  if (isWrapProxyDomRenderProxy(obj)) {
    return obj._domRender_config;
  }
  return undefined;
};
//@ts-ignore
export const getDomRenderProxy = <T>(obj: T): DomRenderProxy<T> | undefined => {
  if (isWrapProxyDomRenderProxy(obj)) {
    //@ts-ignore
    return (obj as any)._domRender_proxy as DomRenderProxy<T>;
  }
  return undefined;
};
export class DomRenderProxy<T extends object> implements ProxyHandler<T> {
  public _domRender_ref = new Map<object, Set<string>>();
  public _rawSets = new Map<string, Set<RawSet>>();
  public _domRender_proxy?: T;
  // public _firstTarget: Node;
  public _targets = new Set<Node>();
  
  // ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ ìºì‹œ
  private static _processingPaths = new Set<string>();
  private static _lastProcessTime = new Map<string, number>();
  
  // DOM ìš”ì†Œ ìºì‹±
  private _elementCache = new WeakMap<Element, { elements: any, timestamp: number }>();
  private static _globalElementCache = new WeakMap<Element, { elements: any, timestamp: number }>();
  
  // ë°°ì¹˜ ì²˜ë¦¬ë¥¼ ìœ„í•œ í•„ë“œë“¤
  private static _pendingUpdates = new Map<string, { value: any, timestamp: number, proxies: Set<DomRenderProxy<any>> }>();
  private static _batchUpdateScheduled = false;
  private static _batchTimeout: any = null;

  constructor(
    public _domRender_origin: T,
    target: Node | null | undefined,
    public _domRender_config: DomRenderConfig
  ) {
    if (target) {
      this._targets.add(target);
      // this._firstTarget = target;
    }

    // setInterval(() => {
    //   this._rawSets.forEach(it => {
    //     Array.from(it).forEach(it => {
    //       console.log(it, it.isConnected)
    //     })
    //   });
    // }, 1000)
  }

  public static unFinal<T = any>(obj: T): T {
    return DomRenderFinalProxy.unFinal(obj);
  }

  public static final<T = any>(obj: T): T {
    return DomRenderFinalProxy.final(obj);
  }

  public static isFinal<T = any>(obj: T) {
    return ValidUtils.isNull(obj) || DomRenderFinalProxy.isFinal(obj);
  }

  public async run(objProxy: T) {
    this._domRender_proxy = objProxy;
    if (isOnProxyDomRender(objProxy)) {
      objProxy.onProxyDomRender(this._domRender_config);
    }
    const obj = getDomRenderOriginObject<any>(objProxy);
    if (obj) {
      Object.keys(obj).forEach(it => {
        // Reflect ë©”íƒ€ë°ì´í„°ì—ì„œ domRender:NoProxy ì—¬ë¶€ í™•ì¸
        try {
          const isNoProxy =
            Reflect.getMetadata(DomRenderNoProxyKey, obj, it) ||
            Reflect.getMetadata(DomRenderNoProxyKey, Object.getPrototypeOf(obj).constructor);
          if (isNoProxy) {
            return obj;
          }
        } catch (e) { }
        const target = obj[it];
        if (
          target !== undefined &&
          target !== null &&
          typeof target === 'object' &&
          !DomRenderProxy.isFinal(target) &&
          !Object.isFrozen(target) &&
          !(obj instanceof Shield)
        ) {
          const isExcluded = this._domRender_config.proxyExcludeTyps?.some(it => target instanceof it) ?? false;
          // const filter = this._domRender_config.proxyExcludeTyps?.filter(it => target instanceof it) ?? [];
          if (!isExcluded) {
            const proxyAfter = this.proxy(objProxy, target, it);
            obj[it] = proxyAfter;
          }
        }
      });
    }
    // console.log('target', this._targets);
    for (let target of this._targets) {
      await this.initRender(target);
    }
  }

  public async initRender(target: Node, rawSet?: RawSet) {
    // if (target instanceof Element) {
    //   target.setAttribute('dr-this', 'this');
    //   const rawSets = RawSet.checkPointCreates(target, this._domRender_proxy, this.config);
    //   this.render(rawSets)
    //   return;
    // }
    //
    if (target instanceof Element) {
      // ì¤‘ìš”: ë‚˜ë¥¼í†µí•´ ì´ì–´ì§„ê³³ì˜ ìœ„ì¹˜ë¥¼ ë‚¨ê²¨ì•¼ëœë‹¤ ì•ˆê·¸ëŸ¬ë©´ TargetElementëŠ” ì•Œìˆ˜ ìˆëŠ” ë°©ë²•ì´ ì—†ë‹¤. ì—¬ê¸°ì„œ í”ì ì„ ë‚¨ê²¨ì¤˜ì•¼ í•œë‹¤.
      // const targetElementNames = (this.config.targetElements?.map(it => it.name.toLowerCase().replaceAll('.', '\\.')) ?? []).join(',');
      // Array.from(target.querySelectorAll(targetElementNames)).forEach(it => it.setAttribute(EventManager.parentVariablePathAttrName, '@this@'));
      target.innerHTML = target.innerHTML.replace(/@this@/g, 'this');
    }
    // TODO: í•œê³³ì—ì„œ ì²˜ë¦¬ í•„ìš”í• ë“¯.. ë„ˆë¬´ ì‚°ë°œì ìœ¼ë¡œ ìˆìŒ.
    const onCreate = (target as any).getAttribute?.(RawSet.DR_ON_CREATE_ARGUMENTS_OPTIONNAME);
    let createParam: any[] = [];
    if (onCreate) {
      createParam = ObjectUtils.Script.evaluateReturn(onCreate, this._domRender_proxy);
      if (!Array.isArray(createParam)) {
        createParam = [createParam];
      }
    }

    if (isOnCreateRenderData(this._domRender_proxy)) {
      this._domRender_proxy?.onCreateRenderData({ rootParent: this._domRender_proxy });
    }

    if (isOnCreateRender(this._domRender_proxy)) {
      this._domRender_proxy.onCreateRender(...createParam);
    }

    // const innerHTML = (target as any).innerHTML ?? '';
    this._targets.add(target);
    const rawSets = RawSet.checkPointCreates(target, this._domRender_proxy, this._domRender_config);
    // console.log('initRender -------rawSet', rawSets)
    // ì¤‘ìš” ì´ˆê¸°ì— í•œë²ˆ íŠ•ê²¨ì¤˜ì•¼í•¨.
    let attrElements;
    if (target instanceof Element) {
      const cached = DomRenderProxy._globalElementCache.get(target);
      const now = Date.now();
      
      if (cached && (now - cached.timestamp) < 100) { // 100ms ìºì‹œ
        attrElements = cached.elements;
        console.log(`ğŸ’¾ initRender: Using cached findAttrElements`);
      } else {
        attrElements = this._domRender_config.eventManager.findAttrElements(target, this._domRender_config);
        DomRenderProxy._globalElementCache.set(target, { elements: attrElements, timestamp: now });
        console.log(`ğŸ” initRender: Fresh findAttrElements`);
      }
    } else {
      attrElements = this._domRender_config.eventManager.findAttrElements(target as Element, this._domRender_config);
    }
    
    this._domRender_config.eventManager.applyEvent(
      this._domRender_proxy,
      attrElements,
      this._domRender_config
    );
    rawSets.forEach(it => {
      const variables = it.getUsingTriggerVariables(this._domRender_config);
      if (variables.size <= 0) {
        this.addRawSet('', it);
      } else {
        variables.forEach(sit => {
          this.addRawSet(sit, it);
        });
      }
    });

    const targetRawSets = await this.render(this.getRawSets());
    for (let targetRawSet of targetRawSets) {
      const onInit = (target as any).getAttribute?.(RawSet.DR_ON_INIT_ARGUMENTS_OPTIONNAME);
      let initParam: any;
      if (onCreate) {
        initParam = ScriptUtils.evaluateReturn(onCreate, this._domRender_proxy);
      }
      if (isOnInitRender(this._domRender_proxy)) {
        await this._domRender_proxy.onInitRender(
          initParam,
          rawSet ?? ({ dataSet: { config: this._domRender_config } } as any)
        );
      }
    }
  }

  public getRawSets() {
    const set = new Set<RawSet>();
    this._rawSets.forEach((v, k) => {
      v.forEach(it => set.add(it));
    });
    return Array.from(set);
  }

  // ì¤‘ìš” important
  public async render(raws?: RawSet[] | string, fullPathStr?: string) {
    if (typeof raws === 'string') {
      const iter = this._rawSets.get(raws);
      if (iter) {
        raws = Array.from(iter);
      } else {
        raws = undefined;
      }
    }
    const removeRawSets: RawSet[] = [];
    const rawSets = raws ?? this.getRawSets();

    // console.log('----', rawSets);
    for (const it of rawSets as RawSet[]) {
      it.getUsingTriggerVariables(this._domRender_config).forEach(path => {
        // console.log('getUsingTriggerVariables->', path);
        this.addRawSet(path, it);
      });

      let renderResult: RenderResult | undefined;
      if (it.isConnected) {
        // ì¤‘ìš” renderë ë•Œ targetAttribute ì²´í¬ í•´ì•¼í•¨.
        const targetAttrMap = (it.point.node as Element)?.getAttribute?.(EventManager.normalAttrMapAttrName);
        // console.log('sssssssssSSS?',it, targetAttrMap)
        // console.log('----2', it, fullPathStr, targetAttrMap, (it.fragment as any).render, it.isConnected, this.getRawSets());
        if (it.detect?.action) {
          it.detect.action();
          // } else if (it.type === RawSetType.TARGET_ELEMENT && it.data && fullPathStr && targetAttrMap && (it.fragment as any).render) {
        } else if (
          it.type === RawSetType.TARGET_ELEMENT &&
          it.dataSet?.render?.currentThis &&
          fullPathStr &&
          targetAttrMap
        ) {
          new Map<string, NormalAttrDataType>(JSON.parse(targetAttrMap)).forEach((v, k) => {
            // it?.data.onChangeAttrRender(k, null, v);
            // console.log('------->?',v,k);
            const isUsing = v.variablePaths.some(it => EventManager.isUsingThisVar(it.inner, `this.${fullPathStr}`))
            // console.log('------->?',v,k, isUsing);
            if (isUsing) {
              const targetAttrObject = RawSet.getAttributeObject(it.point.node as Element, {
                script: it.dataSet?.render?.renderScript ?? '',
                obj: Object.assign(this._domRender_proxy ?? {}, { __render: it.dataSet?.render })
              });
              it.dataSet.render ??= {};
              it.dataSet.render.attribute = targetAttrObject;
              // const render = it.dataSet?.render;
              // console.log('render-->!!!!!', it.dataSet.render);
              // const script = `${render.renderScript} return ${v} `;
              // const cval = ScriptUtils.eval(script, Object.assign(this._domRender_proxy ?? {}, { __render: render }));
              if (isOnChangeAttrRender(it.dataSet?.render?.currentThis)) {
                it.dataSet?.render?.currentThis?.onChangeAttrRender?.(k, targetAttrObject[k], { rawSet: it });
              }
            }
            // console.log('---?', v, fullPathStr, isUsing);
          });
          // ------------------->
        } else {
          const rawSets = await it.render(this._domRender_proxy, this._domRender_config);
          renderResult = rawSets;
          // ê·¸ì™¸ ìì‹ë“¤ render
          if (rawSets && rawSets.raws.length > 0) {
            await this.render(rawSets.raws);
          }
        }
      } else {
        removeRawSets.push(it);
      }

      const t = it.findNearThis(this._domRender_proxy);
      // TODO: í˜¸ì¶œëœê³³ì—ì„œ ë˜ ë³€ìˆ˜ë¥¼ ìˆ˜ì •í•˜ê²Œë˜ë©´ ë¬´í•œë£¨í”„ë‹ˆê¹ ì™ ë§Œí•˜ë©´ ì‚¬ìš©ëª»í•˜ê²Œ í•´ì•¼í•œë‹¤.
      if (isOnRawSetRendered(t)) {
        await t.onRawSetRendered(it, { path: fullPathStr, value: ObjectUtils.Script.evaluateReturn(`this.${fullPathStr}`, this._domRender_proxy), root: this._domRender_proxy, renderResult });
      }
      // console.log('----', it);
    }

    if (removeRawSets.length > 0) {
      this.removeRawSet(...removeRawSets);
    }
    return this.getRawSets();
  }

  // domrender_refë¡œ ì°¾ëŠ”ê±¸ë¡œ ë°”ê¿ˆ
  // public findRootDomRenderProxy(): DomRenderProxy<any> {
  //   let current:DomRenderProxy<any>  = this;
  //   while (current.parentProxy) {
  //     current = current.parentProxy;
  //   }
  //   return current;
  // }

  public root(
    pathInfos: { path: string; obj: any }[][],
    value?: any,
    lastDoneExecute = true
  ): { path: string; obj: any }[][] {
    const rootStartTime = Date.now();
    const pathKey = pathInfos.flat().map(i => i.path).join('.');

    console.group(`ğŸŒ³ DomRenderProxy root: ${pathKey}`);
    
    // ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ ì²´í¬
    const now = Date.now();
    const lastProcessTime = DomRenderProxy._lastProcessTime.get(pathKey);
    
    if (DomRenderProxy._processingPaths.has(pathKey)) {
      console.log(`ğŸš« Already processing path: ${pathKey}`);
      console.groupEnd();
      return [];
    }
    
    // ë°°ì¹˜ ì²˜ë¦¬ ì¤‘ì¸ ê²½ìš° ì²´í¬
    const pendingBatch = DomRenderProxy._pendingUpdates.get(pathKey);
    if (pendingBatch && (now - pendingBatch.timestamp) < 5) { // 5ms ë‚´ ë°°ì¹˜ ì²˜ë¦¬ ëŒ€ê¸° ì¤‘
      console.log(`ğŸ“¦ Batch processing pending for: ${pathKey} (${now - pendingBatch.timestamp}ms ago)`);
      console.groupEnd();
      return [];
    }
    
    if (lastProcessTime && (now - lastProcessTime) < 10) { // 10ms ë‚´ ì¤‘ë³µ ë°©ì§€
      console.log(`ğŸš« Duplicate call prevented for: ${pathKey} (${now - lastProcessTime}ms ago)`);
      console.groupEnd();
      return [];
    }
    
    // ì²˜ë¦¬ ì‹œì‘ ë§ˆí‚¹
    DomRenderProxy._processingPaths.add(pathKey);
    DomRenderProxy._lastProcessTime.set(pathKey, now);
    
    console.log('root--->', pathInfos, value, this._domRender_ref, this._domRender_origin);
    const fullPaths: { path: string; obj: any }[][] = [];
    if (this._domRender_ref.size > 0) {
      this._domRender_ref.forEach((it, key) => {
        if ('_DomRender_isProxy' in key) {
          it.forEach(sit => {
            try {
              const recursiveStartTime = Date.now();
              const concat = pathInfos.concat([[{ path: sit, obj: key }]]);
              const items: { path: string; obj: any }[][] = (key as any)._DomRender_proxy?.root(
                concat,
                value,
                lastDoneExecute
              );
              console.log(`ğŸ”„ Recursive root call for ${sit}: ${Date.now() - recursiveStartTime}ms`);

              fullPaths.push(items.flat());
              // fullPaths.push({path: items.map(it=>it.path).join(','), obj: this._domRender_proxy});
              // fullPaths.push({path: items.map(it=>it.path).join(','), obj: this._domRender_proxy});
            } catch (e) {
              // ì˜¤ë¸Œì íŠ¸ë“¤ ì—†ì–´ì¡Œì„ìˆ˜ë„ìˆë‹¤ Destroyì‹œì ì—ì„œ ì˜¤ë¥˜ë‚˜ëŠ”ê²½ìš°ê°€ ìˆë‹¤. ë”°ë¼ì„œ ì°¸ì¡° í•˜ëŠ”ë¶€ë¶„ ì—†ì–´ì ¸ì•¼í•œë‹¤.
              // console.error(e)
              // it.delete(sit);
            }
          });
        }
      });
    } else {
      const pathProcessStartTime = Date.now();
      // const firstPathStr = paths.slice(1).reverse().join('.');
      const strings = pathInfos.reverse().map(it => it.map(it => it.path).join(','));
      // arrayê°™ì€ê²½ìš°ë„ í‚¤ê°’ìœ¼ë¡œ ì ‘ê·¼í•˜ê¸°ë•Œë¬¸ì— íŠ¹ì • ì¸ë±ìŠ¤ë¥¼ ì°¾ì•„ì„œ ê·¸ë¶€ë¶„ë§Œ ë°”ê¿”ì¤„ìˆ˜ ìˆë‹¤.
      const fullPathStr = strings
        .map(it => (isNaN(Number(it)) ? '.' + it : `[${it}]`))
        .join('')
        .slice(1);
      console.log(`ğŸ›¤ï¸ Path processing time: ${Date.now() - pathProcessStartTime}ms for path: ${fullPathStr}`);
      if (lastDoneExecute) {
        // const firstData = ScriptUtils.evalReturn('this.' + firstPathStr, this._domRender_proxy);
        // console.log('-------', firstPathStr, firstData);
        // if (firstData instanceof Dictionary) {
        // }
        const iterable = this._rawSets.get(fullPathStr);
        // array check
        const front = strings
          .slice(0, strings.length - 1)
          .map(it => (isNaN(Number(it)) ? '.' + it : `[${it}]`))
          .join('');
        const lastPropertyName = strings[strings.length - 1];
        const path = 'this' + front;
        const data = ScriptUtils.evaluateReturn(ObjectUtils.Path.toOptionalChainPath(path), this._domRender_proxy);
        // console.log('root-->', this._rawSets, path, data );
        // console.log('--!!!!', fullPathStr, iterable, data, front, last);
        // ì™œì—¬ê¸°ì„œ promiseë¥¼ í–ˆì„ê¹Œë¥¼ ìƒê°í•´ë³´ë©´......í›”.. ë³€ìˆ˜ë³€ê²½ê³¼ í™”ë©´ ë¿Œë ¤ì£¼ëŠ”ê±¸ ë™ê¸°ë¡œí•˜ë©´ ì„±ëŠ¥ì´ ì•ˆë‚˜ì˜¤ê³  ë¹„í˜„ì‹¤ì ì´ë‹¤.  ê·¸ë˜ì„œ promise
        const promiseStartTime = Date.now();
        new Promise<RawSet[]>(async resolve => {
          const promiseInnerStartTime = Date.now();
          let rData: RawSet[] = [];
          const firstPathStr = front.slice(1);

          // check dictionary
          const dictionaryCheckStartTime = Date.now();
          // console.log('-promise-------', firstPathStr, this)
          const firstTargets = this._rawSets.get(firstPathStr);
          const firstTargetDictionary: RawSet[] = [];
          firstTargets?.forEach(it => {
            // console.log('----forEach---', it);
            const type = (it.point.start as Element)?.getAttribute?.('type');
            if (type === RawSetOperatorType.DR_THIS_PROPERTY) {
              firstTargetDictionary.push(it);
            }
          });
          console.log(`ğŸ“š Dictionary check time: ${Date.now() - dictionaryCheckStartTime}ms (${firstTargetDictionary.length} found)`);

          if (firstTargetDictionary.length > 0) {
            // console.log('ddddddddddd', firstTargetDictionary);
            const rawSets: RawSet[] = [];
            let skip = false;
            firstTargetDictionary.forEach(it => {
              const startElement = it.point.start as Element;
              const keys = startElement.getAttribute(RawSet.DR_HAS_KEYS_OPTIONNAME)?.split(',') ?? [];
              if (value === undefined) {
                const rawSet = it.getHasRawSet(lastPropertyName);
                rawSet?.remove();
                startElement.setAttribute(
                  RawSet.DR_HAS_KEYS_OPTIONNAME,
                  keys.filter(it => it !== lastPropertyName).join(',')
                );
              }
              if (!keys.includes(lastPropertyName)) {
                const raws = DrThisProperty.append(
                  this._domRender_proxy,
                  fullPathStr,
                  lastPropertyName,
                  it,
                  this._domRender_config
                );
                if (raws) {
                  rawSets.push(...raws);
                }
              } else {
                skip = true;
              }
            });
            if (skip === false || rawSets.length > 0) {
              rData = await this.render(rawSets);
            }
          }

          const renderStartTime = Date.now();
          if (lastPropertyName === 'length' && Array.isArray(data)) {
            const aIterable = this._rawSets.get(firstPathStr);
            if (aIterable) {
              rData = await this.render(Array.from(aIterable));
            }
          } else if (iterable) {
            // console.log('------------',iterable, fullPaths)
            rData = await this.render(Array.from(iterable), fullPathStr);
          }
          console.log(`ğŸ¨ Render time: ${Date.now() - renderStartTime}ms (${rData?.length || 0} rawSets)`);

          // console.log('-----------', this, lastPropertyName );
          // this._targets.forEach(it => {
          //   // return;
          //   if (it.nodeType === Node.DOCUMENT_FRAGMENT_NODE || it.nodeType === Node.ELEMENT_NODE) {
          //     const targets = eventManager.findAttrElements((it as DocumentFragment | Element), this.config);
          //     eventManager.changeVar(this._domRender_proxy, targets, `this.${fullPathStr}`, this.config);
          //   }
          // });

          const eventProcessStartTime = Date.now();
          const Node = ((this._domRender_config.window as any).Node)
          this._targets.forEach(it => {
            // return;
            if (it.nodeType === Node.DOCUMENT_FRAGMENT_NODE || it.nodeType === Node.ELEMENT_NODE) {
              const element = it as DocumentFragment | Element;
              const findAttrStartTime = Date.now();
              
              let targets;
              let fromCache = false;
              
              // ìºì‹œ í™•ì¸ (Elementë§Œ ìºì‹œ ê°€ëŠ¥, DocumentFragmentëŠ” ì œì™¸)
              if (element instanceof Element) {
                const cached = DomRenderProxy._globalElementCache.get(element);
                const now = Date.now();
                
                if (cached && (now - cached.timestamp) < 100) { // 100ms ìºì‹œ
                  targets = cached.elements;
                  fromCache = true;
                  const targetCount = (targets as any)?.size || (targets as any)?.length || 0;
                  console.log(`ğŸ’¾ Using cached findAttrElements (${targetCount} elements)`);
                } else {
                  targets = this._domRender_config.eventManager.findAttrElements(element, this._domRender_config);
                  DomRenderProxy._globalElementCache.set(element, { elements: targets, timestamp: now });
                }
              } else {
                // DocumentFragmentëŠ” ìºì‹œí•˜ì§€ ì•ŠìŒ
                targets = this._domRender_config.eventManager.findAttrElements(element, this._domRender_config);
              }
              
              const targetCount = (targets as any)?.size || (targets as any)?.length || 0;
              if (!fromCache) {
                console.log(`ğŸ” Fresh findAttrElements time: ${Date.now() - findAttrStartTime}ms (${targetCount} elements)`);
              }

              const changeVarStartTime = Date.now();
              this._domRender_config.eventManager.changeVar(
                this._domRender_proxy,
                targets,
                `this.${fullPathStr}`,
                this._domRender_config
              );
              console.log(`ğŸ”„ changeVar time: ${Date.now() - changeVarStartTime}ms`);
            }
          });
          console.log(`âš¡ Event processing time: ${Date.now() - eventProcessStartTime}ms (${this._targets.size} targets)`);

          console.log(`ğŸ”„ Promise inner total time: ${Date.now() - promiseInnerStartTime}ms`);

          //ëœë”ëŒ€ìƒëœê²Œìˆìœ¼ë©´
          if (rData?.length > 0 && isOnChildRenderedByProperty(data)) {
            const propertyValue = ObjectUtils.Script.evaluateReturn(`this.${lastPropertyName}`, data);
            data.onChildRenderedByProperty(lastPropertyName, propertyValue);
            // data
          }
          resolve(rData);
        }).then(it => {
          // console.log('DonrenderProxy root RenderDone')
        });
      }
      fullPaths.push([{ path: fullPathStr, obj: this._domRender_proxy }]);
    }

    // ì²˜ë¦¬ ì™„ë£Œ ë§ˆí‚¹
    DomRenderProxy._processingPaths.delete(pathKey);
    
    console.log(`ğŸ Root method total time: ${Date.now() - rootStartTime}ms`);
    console.log('dddddd', fullPaths.flatMap(it => it).map(it => it.path))
    console.groupEnd();
    return fullPaths;
  }

  public set(target: T, p: string | symbol, value: any, receiver: T): boolean {
    // console.log('set------->', target, p, value, receiver, Date.now())
    // console.log('set------->', p,value)
    // console.log('set------->', target, p, value, receiver, Date.now())
    // try {
    //   const isNoProxy = Reflect.getMetadata(DomRenderNoProxyKey, target, p) || Reflect.getMetadata(DomRenderNoProxyKey, Object.getPrototypeOf(obj).constructor);
    //   if (isNoProxy) {
    //     return obj;
    //   }
    // }catch (e) {}

    // console.log('set-->', p, value, target, receiver, Reflect.getMetadata(DomRenderNoProxyKey, target, p) );

    if (
      (typeof p === 'string' && p !== '__domrender_components' && excludeGetSetPropertys.includes(p)) ||
      Reflect.getMetadata(DomRenderNoProxyKey, target, p)
    ) {
      (target as any)[p] = value;
      return true;
    }
    // const old =  (target as any)[p];
    // console.log('set proxy-->', target, p, value, this._rawSets, this._domRender_ref);
    // if (typeof p === 'string' && '__render' === p) {
    //     (target as any)[p] = value;
    //     return true;
    // }
    // console.log('set--?', p, target, value);

    if (typeof p === 'string') {
      value = this.proxy(receiver, value, p);
    }

    // console.log('set typeChecked',  (target as any)[p] instanceof ComponentSet, value instanceof ComponentSet);
    // if ((target as any)[p] instanceof ComponentSet) {
    //   (target as any)[p]?.obj?.onDrThisUnBind?.();
    // }
    // is ComponentSet
    if (value instanceof ComponentSet && (target as any)[p] instanceof ComponentSet) {
      value.config.beforeComponentSet = (target as any)[p];
    }
    (target as any)[p] = value;
    let fullPathInfo: { path: string; obj: any }[][] = [];
    if (typeof p === 'string') {
      // ë°°ì¹˜ ì²˜ë¦¬ë¡œ ë³€ê²½
      this.scheduleBatchUpdate(p, value);
      // ì¦‰ì‹œ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš°ë¥¼ ìœ„í•´ ê¸°ë³¸ root í˜¸ì¶œë„ ìœ ì§€ (í•˜ì§€ë§Œ ë°°ì¹˜ì—ì„œ ì¤‘ë³µ ì œê±°ë¨)
      fullPathInfo = this.root([[{ path: p, obj: this._domRender_proxy }]], value);
    }

    // console.log('setRooot', fullPathInfo);

    //normal attribute ë˜í•œ ë§í¬ë‘ ê°™ì€ ì¦ì„¸ë¼ì„œ ì´ë ‡ê²Œ í•´ì¤˜ì•¼í•œë‹¤!!
    // const rootDomRenderProxy = this.findRootDomRenderProxy();
    // console.log('set!!!!!!!', fullPathInfo, rootDomRenderProxy)
    // console.log('--------rootDom',fullPathInfo, rootDomRenderProxy, rootDomRenderProxy._domRender_proxy)
    const rootElement = this._domRender_config.rootElement ?? this._domRender_config.window.document;
    DocumentUtils.querySelectorAllByAttributeName(rootElement, EventManager.normalAttrMapAttrName)?.forEach(
      elementInfo => {
        // @ts-ignore
        // const optionalPath = ObjectUtils.Path.toOptionalChainPath(elementInfo.value);
        const targets = new Map<string, NormalAttrDataType>(
          ObjectUtils.Script.evaluateReturn<[string, NormalAttrDataType][]>(elementInfo.value)
        );
        Array.from(targets.entries())
          .filter(isDefined)
          .flatMap(([key, valueScript]) => {
            return fullPathInfo
              .flat()
              .filter(it => valueScript.variablePaths?.some(vit => vit.inner.includes(`this.${it.path}`)))
              .flatMap(it => ({ key, valueScript: valueScript, pathInfo: it }));
          })
          .forEach(it => {
            // const optionalPaths = it.valueScript.variablePaths.map(it => ObjectUtils.Path.toOptionalChainPath(it))
            const variablePaths = it.valueScript.variablePaths;
            let targetScript = it.valueScript.originalAttrValue;
            let script: string;
            if (it.valueScript.isStringTemplate) {
              variablePaths.forEach(it => {
                let r = ObjectUtils.Path.toOptionalChainPath(it.inner);
                targetScript = targetScript.replaceAll(it.origin, `\${${r}}`);
              })
              script = '`' + targetScript + '`';
            } else {
              variablePaths.forEach(it => {
                let r = ObjectUtils.Path.toOptionalChainPath(it.inner);
                targetScript = targetScript.replaceAll(it.origin, `${r}`);
              })
              script = targetScript;
            }
            // variablePaths.forEach(it => {
            //   let r = ObjectUtils.Path.toOptionalChainPath(it.inner);
            //   targetScript = targetScript.replaceAll(it.origin,`\${${r}}`);
            // })
            const value1 = ObjectUtils.Script.evaluateReturn(script, it.pathInfo.obj);
            // console.log('proxy set!Attribut======', it.key, value1)
            if (value1 === null) {
              elementInfo.element.removeAttribute(it.key);
              elementInfo.element[it.key] = null;
            } else {
              elementInfo.element.setAttribute(it.key, value1);
              elementInfo.element[it.key] = value1;
            }
          });
      }
    );

    //ì—¬ê¸°ì„œ ë§í¬ ê°™ì€ê±° í•´ì¤˜ì•¼í•¨  *-linkë¡œ ë³€ìˆ˜ê°’ì´ ë³€ê²½ë˜ë©´ ê·¸ê±¸ ì°¸ê³ í•˜ê³ ìˆëŠ” ë‹¤ë¥¸ê²ƒë“¤ì—ë„ í•´ì¤˜ì•¼í•œë‹¤.
    DocumentUtils.querySelectorAllByAttributeName(rootElement, EventManager.linkTargetMapAttrName)?.forEach(
      elementInfo => {
        // @ts-ignore
        const targets = new Map<string, string>(ScriptUtils.evaluateReturn<[string, string][]>(elementInfo.value));

        Array.from(targets.entries())
          .filter(([key, value]) => value.trim())
          .filter(isDefined)
          .flatMap(([key, valueScript]) => {
            return fullPathInfo
              .flat()
              .filter(it => valueScript.includes(`this.${it.path}`))
              .flatMap(it => ({ key, valueScript: valueScript, pathInfo: it }));
          })
          .forEach(info => {
            const value1 = ScriptUtils.evaluateReturn(info.valueScript, info.pathInfo.obj);
            const applyAttributeName = EventManager.linkAttrs.find(it => it.name === info.key);
            if (applyAttributeName) {
              if (value1 === null) {
                elementInfo.element.removeAttribute(applyAttributeName.property);
              } else {
                // console.log('ppppppppppppppppppppppp', applyAttributeName, elementInfo)
                elementInfo.element.setAttribute(applyAttributeName.property, value1);
              }
            }
          });

        Array.from(targets.entries())
          .filter(([key, value]) => value.trim())
          .filter(isDefined)
          .flatMap(([key, valueScript]) => {
            return fullPathInfo
              .flat()
              .filter(it => valueScript.includes(`this.${it.path}`))
              .flatMap(it => ({ key, valueScript: valueScript, pathInfo: it }));
          })
          .forEach(info => {
            const linkInfo = EventManager.linkAttrs.find(it => it.name === info.key);
            if (linkInfo) {
              elementInfo.element[linkInfo.property] = value;
            }
          });
      }
    );

    // console.log('---end',receiver);
    if (
      'onBeforeReturnSet' in receiver &&
      typeof p === 'string' &&
      !(this._domRender_config.proxyExcludeOnBeforeReturnSets ?? []).concat(excludeGetSetPropertys).includes(p)
    ) {
      if (isOnBeforeReturnSet(receiver)) {
        receiver.onBeforeReturnSet?.(
          p,
          value,
          fullPathInfo.map(it => it.map(it => it.path).join())
        );
      }
    }
    return true;
  }

  get(target: T, p: string | symbol, receiver: any): any {
    // console.log('get-->', target, p, receiver);
    if (p === '_DomRender_origin' || p === '_domRender_origin') {
      return this._domRender_origin;
    } else if (p === '_DomRender_ref' || p === '_domRender_ref') {
      return this._domRender_ref;
    } else if (p === '_DomRender_config' || p === '_domRender_config') {
      return this._domRender_config;
    } else if (p === '_DomRender_proxy' || p === '_domRender_proxy') {
      return this;
    } else {
      // Dateë¼ë˜ì§€ ì´ëŸ°ë†ˆë“¤ì€-_-í”„ë¡ì‹œê°€ ì´ìƒí•˜ê²Œ ë™ì‘í•´ì„œ
      // console.log('--->', p, target, target.bind, 'bind' in target)
      // if ((p in target) && ('bind' in target)) {
      //     try{
      //     return (target as any)[p].bind(target);
      //     }catch (e) {
      //         console.error(e)
      //     }
      // } else {
      //     return (target as any)[p]
      // }
      // return (p in target) ? (target as any)[p].bind(target) : (target as any)[p]
      // console.log('-->', p, Object.prototype.toString.call((target as any)[p]), (target as any)[p])
      // return (target as any)[p]
      let it = (target as any)[p];
      if (
        it &&
        typeof it === 'object' &&
        '_DomRender_isProxy' in it &&
        Object.prototype.toString.call(it._DomRender_origin) === '[object Date]'
      ) {
        it = it._DomRender_origin;
      }

      if (
        'onBeforeReturnGet' in receiver &&
        typeof p === 'string' &&
        !(this._domRender_config.proxyExcludeOnBeforeReturnGets ?? []).concat(excludeGetSetPropertys).includes(p)
      ) {
        (receiver as any)?.onBeforeReturnGet?.(
          p,
          it,
          this.root([[{ path: p, obj: this._domRender_proxy }]], it, false)
        );
      }
      return it;
    }
  }

  deleteProperty(target: T, p: string | symbol): boolean {
    delete (target as any)[p];
    if (typeof p === 'string') {
      this.root([[{ path: p, obj: this._domRender_proxy }]]);
    }
    return true;
  }

  has(target: T, p: string | symbol): boolean {
    return p === '_DomRender_isProxy' || p in target;
  }

  proxy(parentProxy: T, obj: T | any, p: string) {
    try {
      // const isNoProxy = Reflect.getMetadata(DomRenderNoProxyKey, obj, p) || Reflect.getMetadata(DomRenderNoProxyKey, Object.getPrototypeOf(obj).constructor);
      const isObject = typeof obj === 'object';
      const isNoProxy = isObject && isDomRenderNoProxy(obj, p);
      const isExclude = this._domRender_config.proxyExcludeTyps?.some(it => obj instanceof it) ?? false;
      const isFinal = isObject && DomRenderProxy.isFinal(obj);
      const isFrozen = Object.isFrozen(obj);
      const isShield = obj instanceof Shield;
      if (
        obj === undefined ||
        obj === null ||
        isNoProxy ||
        isExclude ||
        ValidUtils.isNullOrUndefined(obj) ||
        !isObject ||
        isFinal ||
        isFrozen ||
        isShield
      ) {
        return obj;
      }
    } catch (e) { }

    /*
    const proxyTarget = (this._domRender_config.proxyExcludeTyps?.filter(it => obj instanceof it) ?? []).length <= 0;
    if (proxyTarget && obj !== undefined && obj !== null && typeof obj === 'object' && !('_DomRender_isProxy' in obj) && !DomRenderProxy.isFinal(obj) && !Object.isFrozen(obj) && !(obj instanceof Shield)) {
      const domRender = new DomRenderProxy(obj, undefined, this._domRender_config);
      domRender.addRef(parentProxy, p);
      const proxy = new Proxy(obj, domRender);
      domRender.run(proxy);
      return proxy;
    }
    if (proxyTarget && obj !== undefined && obj !== null && typeof obj === 'object' && ('_DomRender_isProxy' in obj) && !DomRenderProxy.isFinal(obj) && !Object.isFrozen(obj) && !(obj instanceof Shield)) {
      const d = (obj as any)._DomRender_proxy as DomRenderProxy<T>;
      d.addRef(this._domRender_proxy!, p);
      return obj;
    } else {
      return obj;
    }
 */
    if (!isWrapProxyDomRenderProxy(obj)) {
      const domRender = new DomRenderProxy(obj, undefined, this._domRender_config);
      domRender.addRef(parentProxy, p);
      const proxy = new Proxy(obj, domRender);
      domRender.run(proxy);
      return proxy;
    }
    if (isWrapProxyDomRenderProxy(obj)) {
      const d = (obj as any)._DomRender_proxy as DomRenderProxy<T>;
      d.addRef(this._domRender_proxy!, p);
      return obj;
    } else {
      return obj;
    }
  }

  public addRef(parent: object, path: string) {
    if (!this._domRender_ref.get(parent)) {
      this._domRender_ref.set(parent, new Set<string>());
    }
    this._domRender_ref.get(parent)?.add(path);
  }

  public addRawSetAndRender(path: string, rawSet: RawSet) {
    this.addRawSet(path, rawSet);
    this.render([rawSet]);
  }

  public addRawSet(path: string, rawSet: RawSet) {
    // console.log('addRawSet--> path:', path, 'rawSet:', rawSet)
    if (!this._rawSets.get(path)) {
      this._rawSets.set(path, new Set<RawSet>());
    }
    this._rawSets.get(path)?.add(rawSet);
  }

  // public removeRawSet(...raws: RawSet[]) {
  //     this._rawSets.forEach(it => {
  //         raws.forEach(sit => it.delete(sit));
  //     })
  //     this.garbageRawSet();
  // }

  public removeRawSet(...raws: RawSet[]) {
    this._rawSets.forEach(it => {
      it.forEach(sit => {
        if (!sit.isConnected) {
          it.delete(sit);
        } else if (raws.includes(sit)) {
          it.delete(sit);
        }
      });
    });
    this.targetGarbageRawSet();
  }

  private targetGarbageRawSet() {
    this._targets.forEach(it => {
      if (!it.isConnected) {
        this._targets.delete(it);
      }
    });
  }

  // ë°°ì¹˜ ì²˜ë¦¬ ë©”ì„œë“œë“¤
  private scheduleBatchUpdate(path: string, value: any) {
    const now = Date.now();
    const existing = DomRenderProxy._pendingUpdates.get(path);
    
    if (existing) {
      // ê¸°ì¡´ ì—…ë°ì´íŠ¸ê°€ ìˆìœ¼ë©´ ê°’ê³¼ í”„ë¡ì‹œ ëª©ë¡ ì—…ë°ì´íŠ¸
      existing.value = value;
      existing.timestamp = now;
      existing.proxies.add(this);
      console.log(`ğŸ“¦ Batch: Updated pending update for ${path} (${existing.proxies.size} proxies)`);
    } else {
      // ìƒˆë¡œìš´ ì—…ë°ì´íŠ¸ ì¶”ê°€
      DomRenderProxy._pendingUpdates.set(path, {
        value,
        timestamp: now,
        proxies: new Set([this])
      });
      console.log(`ğŸ“¦ Batch: Added new pending update for ${path}`);
    }
    
    // ë°°ì¹˜ ì²˜ë¦¬ ìŠ¤ì¼€ì¤„ë§
    this.scheduleBatchProcessing();
  }

  private scheduleBatchProcessing() {
    if (DomRenderProxy._batchUpdateScheduled) {
      return; // ì´ë¯¸ ìŠ¤ì¼€ì¤„ë¨
    }
    
    DomRenderProxy._batchUpdateScheduled = true;
    
    // ê¸°ì¡´ íƒ€ì„ì•„ì›ƒ í´ë¦¬ì–´
    if (DomRenderProxy._batchTimeout) {
      clearTimeout(DomRenderProxy._batchTimeout);
    }
    
    // ì§§ì€ ì§€ì—° í›„ ë°°ì¹˜ ì²˜ë¦¬ (ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ í ì‚¬ìš©)
    DomRenderProxy._batchTimeout = setTimeout(() => {
      this.processBatchUpdates();
    }, 0);
    
    console.log(`â° Batch processing scheduled (${DomRenderProxy._pendingUpdates.size} pending)`);
  }

  private processBatchUpdates() {
    const batchStartTime = Date.now();
    const updateCount = DomRenderProxy._pendingUpdates.size;
    
    console.group(`ğŸš€ Processing batch updates (${updateCount} items)`);
    
    try {
      // ëª¨ë“  ëŒ€ê¸° ì¤‘ì¸ ì—…ë°ì´íŠ¸ ì²˜ë¦¬
      DomRenderProxy._pendingUpdates.forEach((updateInfo, path) => {
        const updateStartTime = Date.now();
        
        // ê° í”„ë¡ì‹œì—ì„œ root í˜¸ì¶œ (ì¤‘ë³µ ë°©ì§€ ë¡œì§ì´ ì ìš©ë¨)
        updateInfo.proxies.forEach(proxy => {
          try {
            proxy.root([[{ path, obj: proxy._domRender_proxy }]], updateInfo.value);
          } catch (error) {
            console.error(`âŒ Batch update error for ${path}:`, error);
          }
        });
        
        console.log(`âœ… Batch processed ${path}: ${Date.now() - updateStartTime}ms (${updateInfo.proxies.size} proxies)`);
      });
      
      // ëŒ€ê¸° ëª©ë¡ í´ë¦¬ì–´
      DomRenderProxy._pendingUpdates.clear();
      
    } finally {
      // ìŠ¤ì¼€ì¤„ë§ í”Œë˜ê·¸ ë¦¬ì…‹
      DomRenderProxy._batchUpdateScheduled = false;
      DomRenderProxy._batchTimeout = null;
      
      console.log(`ğŸ Batch processing completed: ${Date.now() - batchStartTime}ms`);
      console.groupEnd();
    }
  }

  private garbageRawSet() {
    this._targets.forEach(it => {
      if (!it.isConnected) {
        this._targets.delete(it);
      }
    });

    this._rawSets.forEach(it => {
      it.forEach(sit => {
        if (!sit.isConnected) {
          it.delete(sit);
        }
      });
    });
    
    // ìºì‹œ ì •ë¦¬: 5ì´ˆ ì´ìƒ ëœ í•­ëª© ì œê±°
    const now = Date.now();
    DomRenderProxy._lastProcessTime.forEach((time, key) => {
      if (now - time > 5000) {
        DomRenderProxy._lastProcessTime.delete(key);
      }
    });
    
    // ë°°ì¹˜ ì²˜ë¦¬ ì •ë¦¬: 10ì´ˆ ì´ìƒ ëœ ëŒ€ê¸° ì—…ë°ì´íŠ¸ ì œê±°
    DomRenderProxy._pendingUpdates.forEach((updateInfo, key) => {
      if (now - updateInfo.timestamp > 10000) {
        console.log(`ğŸ§¹ Cleaning old batch update: ${key}`);
        DomRenderProxy._pendingUpdates.delete(key);
      }
    });
    
    // DOM ìºì‹œ ì •ë¦¬ëŠ” WeakMapì´ë¯€ë¡œ ìë™ìœ¼ë¡œ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ë¨
    // í•˜ì§€ë§Œ ëª…ì‹œì ìœ¼ë¡œ ì˜¤ë˜ëœ ìºì‹œ ì •ë¦¬ (WeakMapì€ ì§ì ‘ ìˆœíšŒ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ ë³„ë„ ê´€ë¦¬ í•„ìš”ì‹œì—ë§Œ)
  }
}
